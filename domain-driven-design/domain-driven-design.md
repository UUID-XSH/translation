# 领域驱动设计

## 关于领域驱动设计

这篇文章参考自Eric Evans《领域驱动设计》一书以及Jimmy Nilsson《以C# .NET为例运用领域驱动设计和模式》，二者详细描述了领域驱动设计的核心概念、技术和模式。在某些情况下，直接使用这些书的措辞是有意义的，并且我认为Eric Evans和Jimmy Nilsson也允许我们这么做。

尽管将模式本身呈现出来是很有用的,但是仅仅对模式进行描述，DDD的许多微妙之处就会消失。这些模式应该是你的工具，而不是你束缚你的规则。它们是为设计而生的语言，在团队内沟通创意和模型十分有益。更为重要的是，记住实践DDD的目的是为了做出更加务实的决定。不要试图将一个模式强加于一个模型。另外，如果你“违背”了一个模式，确保你已经理解了这么做的理由，并将其与其他人沟通。

通常认为，DDD在面向对象范式下表现良好，但远不止这些。DDD挑战了如何去理解问题空间，甚至让这些理解变得可交流。

值得注意的是，DDD还鼓励将其他领域的概念纳入其中，比如测试驱动开发，使用设计模式，以及持续重构。

## 代表模型

领域驱动设计的最主要目的是为了设计和创造出富有表达力的模型。同样，DDD也致力于创造出让参与到软件开发中的各方都能理解的模型。

由于非技术人员同样需要使用这些模型工作，所以如果能用不同的方式进行表达将变得极为便利。典型的，描述一个领域模型的方式有多种，UML草图，代码以及领域语言。

### 使用语言

正在考虑参加培训课程的人会根据主题、成本、以及课程安排搜索课程表。当一个课程被订阅后，一个注册邀请会被下发给订阅人，订阅人可以在稍后选择取消或者接受。

### 使用代码

```
class Person {
    public Registration bookCourse(Course c) { ... } 
}
abstract class Registration { 
    public abstract void accept();
    public abstract void cancel(); 
}
class ReservedRegistration extends Registration { ... } 
class AcceptedRegistration extends Registration { ... }
interface CourseRepository {
public List<Course> find(...); }
```

### 使用ULM草图

(此处放置原文的图片)

## 通用语言

一致地使用通用语言对理解和传达在领域中发现的内涵信息至关重要。在领域驱动开发中，我们通常讨论的是概念而非名词或者动词。概念的意图，其意义和价值对于理解和传达信息至关重要。如何去实现这种意图虽然很重要，但是对于每个意图来说，其实现有很多种。为了理解和分享这些意图，任何人必须在任何地方和任何机会下使用这些语言。当你使用通用语言时，和领域专家的合作将变得更加富有创意和价值。

注意，由于语言中的技术和业务障碍，领域专家可能会隐藏或者模糊重要概念。通常这些术语和实现有关而非领域概念。DDD虽然不会排除实现，但是它从更高的层次去反应模型的用途。

考虑下面的描述:

当一个人订阅了一个课程，如果课程已经满员，那么这个人会得到一个“等待”的状态。一旦课程还有名额可用，那么我们的消息总线必须给这个人发送详细信息以使得支付网关继续处理。

以上描述有一些潜在的障碍。这些术语不会增加价值，但是它们是深入挖掘领域驱动设计的极好线索。

用户有一个状态

状态可能是一个标志或者字段。也许领域专家对其他系统如电子表格很熟悉，并建议使用同样的实现。

通过我们的消息总线发送

这是一个技术实现。实际上在领域中，通过我们的消息总线发送信息没有任何后果。

处理

这是模棱两可并且迷糊的描述，处理过程中会发生什么？

支付网关

另一个实现。实际上此处更为重要的是支付的一些方式而不是支付的实现。

## 策略设计

策略设计讨论的是大而复杂的设计，重点是构成大型模型的许多部分，以及这些部分之间如何相互关联。这有利于设计向前推进，取得足够的进展，而不是掉进“我的模型被强制转化成石头”这一陷阱。

在DDD，这些小的模型存在于上下文的边界，这些有界上下文相互关联的方式称为上下文映射。

### 上下文边界

对于每一个模型，应该有意和明确地去定义其所处的上下文。创建上下文并没有特定的规则，但重要的是让每个人都能理解上下文的边界条件。

一个系统下的各个团队如果对于不同的上下文以及他们之间的关系没有一个很好的理解，那么在整合有界上下文时会冒着妥协模式的风险。如果团队没有明确的映射和了解上下文之间的关系，那么模型之间的线条可能会因为数量爆炸而变得越发模糊。

上下文可能会以如下方式被创建(但是不限于)：

团队的组织方式

代码库的结构和布局

在特定领域范围内被使用

我们的目标是在上下文中保持一致性和统一性，而不要由于上下文外部的领域而分散精力。其他的上下文将具有不同的模型和不同的概念。对于其他上下文来说，使用领域通用语言的一种不同的方言是很常见的行为。

### 上下文映射

上下文映射是针对连接点的设计过程，同时有界上下文之间的转义关系应该被明确的反应出来。我们应该着重于处理现有界限之间的映射关系，之后再去处理实际的转换。

HOT TIP:在单个有限的上下文中使用持续集成，以缓解由于不同的理解产生的碎片。频繁的代码合并，自动化测试，使用通用语言会加剧促使有界上下文中碎片的产生。

### 上下文映射模式

用于上下文映射的模式有很多，其中的一些将在下文中得到解释。

HOT TIP:慎重的去对待共享内核!它们很难设计和维护，并且几乎在高度成熟的团队才有效果。

#### 共享内核

共享内核是一个有限上下文，它是领域的一个子集，供不同团队分享，而这需要团队之间的良好沟通和协作。记住它与最低公分母不符。

#### 消费者/生产者开发团队

当一个有界上下文服务于或者消费另一个有界上下文，那么下游的上下文将会依赖于上游上下文。明确上下文处于上游或者下游能使其提供者或者消费者的身份变得更加清晰。

#### 一致性模式

当一个工作于下游的团队没有影响力或者没有机会与上游团队进行合作时，那么他们别无选择，只能遵从于上游。处于上游的上下文有很多理由去“主宰”提供给下游上下文的接口，
但是切换到一个一致的模式会消除许多痛苦。简单的与上游接口保持一致，降低的复杂度往往会超过尝试改变不可更改的接口的复杂度。

一般来说，下游模型的质量一般会遵循上游模型的质量。如果上游模型设计的比较好，那么下游的模型也同样良好。但是，如果上游的模型设计的比较差，那么下游的模型会同样不堪。无论如何，上游模型将不会适应下游需求，因此不会完美契合。

HOT TIP:一致性模式需要更多的实用主义。上游模型的质量及其适应性可能“足够好”，这表明你不会想让你正在工作的上下文处在一致性关系中的核心领域。

#### 隔离层
当试图给不同系统中的上下文建立联系时，会导致一个模型渗透到另外一个模型中，那么它们的意图将会在两者的混乱组合中丢失。在这种情况下，最好让两个上下文保持良好的距离，并在期间引入隔离层，负责在两个方向上进行翻译。

HOT TIP:隔离层是处理遗留系统或将逐步淘汰的代码库的一个很好的模式。


#### 独立方式
严格分析有界上下文之间的映射。如果没有不可或缺的功能关系，那么请将上下文分开。这么做的理由是整合在一起的成本高，而收益率很低。这种大大消除了复杂性，因为它允许开发人员（甚至业务经理）在非常有限的范围内找到高度集中的解决方案。

## 为领域建模
在处理有界上下文时，我们要重点关注建立真正的有表达力的模型;这些模型更多的反应意图而不是实现。一旦我们这样做了，领域的概念就会显得非常自然，并且模型设计也会变得灵活和易于重构。DDD模式更多地是来自Fowler等人关于GoF的模式的应用，特别是在建模主题领域。下面是最常见的模式:

### 处理结构

#### 实体

实体类的特征是它的实例可以全局辨识、并且保持一致的身份。其他属性可能会有状态变化，但身份永远不会改变。

在这里例子中，Address可能会变更很多次，但是Client的标识不会变，无论其他属性怎么改变它们的状态。

#### 值对象
值对象都是轻量级、不可变并且没有标识的。虽然它的值很重要，但是它不是简单的数据传输对象。值对象是放置复杂计算的好场所，因此将笨重的业务逻辑从实体对象中转移了出来。它们更容易、更安全的被组合,并且由于它们将复杂的业务逻辑从实体中转移，从而帮助实体更加专注于追踪其生命周期。

在这个例子中，当Client的地址发生变化时，然后将一个新的Address值对象实例化并分配给Client。

HOT TIP:值对象具有简单的生命周期，并且可以大大简化你的模型。他们也非常适合在静态类型语言的编译时期引入类型安全。并且由于值对象的方法应该是无副作用的，他们也增加了一些功能性的编程风格。

#### 关联系数
类之间的关联系数越大，意味着数据结构越复杂。我们可以通过添加限定词来降低系数。

双向关联也增加了复杂性。批判性的去询问模型的问题，以确定是否一定必须在两个对象的两个方向上进行访问。

在这个例子中，我们并不需要向所有Project对象询问Person对象，但是我们总是要在Person所有角色中询问一个Project对象，这样我们就可以使关系维持在一个方向上。方向意味着在内存中是以何种方式维护着对象之间的关系。如果我们需要检索出一个Person对象的所有Project对象，我们可以在一个Repository(见下文)中执行一个查询。

#### 服务层
有时候不可能将一个行为分配给任何一个类，无论是实体还是值对象。很多场景都是对多个类进行操作的纯粹的功能运算，而不是一个单一的类为该行为负责。在这种情况下，引入了一种称为服务类的无状态的类来封装此行为。
 
#### 聚合
随着我们往模型里面添加越来越多的东西，对象图会变得相当大而复杂。过大的对象图使诸如事务边界，分布式和并发等技术实现非常困难。聚合拥有一致性边界，使得边界内的类与对象图的其他部分“断开连接”。每个聚合都有一个实体作为聚合的“根”。

当我们创建聚合时，要确保聚合仍然被视为域中有意义的单元。另外，通过使用“删除”测试来测试聚合边界的正确性。在删除测试中，如果根被删除，则批判性地检查聚合中的哪些对象（以及聚合之外）也将被删除。

按照这些简单的规则进行聚合:
根具有全局身份，而其他的只有本地身份
根检查所有的常量是否被满足
聚合外面的实体仅仅持有对根的引用
删除操作会移除整个聚合内的所有内容
当有对象发生变化时，必须满足所有常量

HOT TIP:记住聚合的两个作用:简化领域设计和改进技术。聚合之间可能存在不一致之处，但所有聚合最终彼此一致

### 处理生命周期

#### 工厂(FACTORIES)
工厂管理着一些聚合的生命周期的开端，这是GoF工厂或建造者模式的应用。必须注意聚合体的规则得到遵循，尤其是聚合内的不变量。务实的去使用工厂模式。记住，工厂有时非常有用，但不是必需的。

#### 仓库(REPOSITORIES)
工厂管理生命周期的开始，而仓库管理生命周期的中间和末尾.仓库可能将持久化的责任委托给负责检索对象的ORM框架。记住，仓库也是用聚合的方式进行工作。所以检索到的对象应该遵守聚合规则。

### 处理行为

#### 规约模式

#### 策略模式

#### 组合模式

## 应用架构

## 最近添加的模式


